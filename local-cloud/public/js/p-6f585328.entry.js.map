{"version":3,"names":["pickerIosCss","IonPickerIosStyle0","pickerMdCss","IonPickerMdStyle0","Picker","constructor","hostRef","this","useInputMode","isInHighlightBounds","ev","highlightEl","bbox","getBoundingClientRect","outsideX","clientX","left","right","outsideY","clientY","top","bottom","onFocusOut","relatedTarget","tagName","inputEl","exitInputMode","onFocusIn","target","actionOnClick","columnEl","allowInput","numericInput","enterInputMode","onClick","undefined","onPointerDown","inputModeColumn","el","columns","querySelectorAll","length","focusInput","hasInputColumn","querySelector","destroyKeypressListener","focus","addEventListener","onKeyPress","removeEventListener","emitInputModeChange","parsedValue","parseInt","key","Number","isNaN","value","onInputChange","selectSingleColumn","singleColumnSearchTimeout","options","Array","from","filter","disabled","clearTimeout","setTimeout","startIndex","newString","substring","findItemFromCompleteValue","find","textContent","parsedText","replace","setValue","changedCharacter","searchColumn","colEl","zeroBehavior","behavior","option","selectMultiColumn","numericPickers","col","firstColumn","lastColumn","minuteValue","firstCharacter","firstCharacterAgain","firstCharacterAgainAgain","minuteValueAgain","ionInputModeChange","emit","preventTouchStartPropagation","stopPropagation","componentWillLoad","getElementRoot","blur","render","h","Host","tabindex","inputmode","type","onKeyDown","_a","ref","onInput","onBlur","class","pickerColumnCss","IonPickerColumnStyle0","PickerColumn","isScrolling","isColumnVisible","canExitInputMode","updateValueTextOnScroll","centerPickerItemInView","smooth","scrollEl","offsetTop","clientHeight","scrollTop","scroll","setPickerItemActiveState","item","isActive","classList","add","PICKER_ITEM_ACTIVE_CLASS","remove","inputModeChange","detail","isColumnActive","setInputModeActive","state","scrollEndCallback","initializeScrollListener","enableHaptics","isPlatform","timeout","activeEl","activeItem","scrollCallback","raf","hapticSelectionStart","centerX","x","width","centerY","y","height","rootNode","getRootNode","hasParentShadow","ShadowRoot","referenceNode","doc","elementsAtPoint","elementsFromPoint","newActiveElement","hapticSelectionChanged","assistiveFocusable","setAttribute","getOptionValueText","hapticSelectionEnd","destroyScrollListener","parentEl","findNextOption","stride","prevNode","node","nextElementSibling","findPreviousOption","nextNode","previousElementSibling","mobile","newOption","preventDefault","getAttribute","innerText","renderAssistiveFocusable","valueText","role","ariaLabel","color","ariaLabelChanged","newValue","valueChange","scrollActiveItemIntoView","closest","visibleCallback","entries","isIntersecting","oldActive","IntersectionObserver","threshold","root","observe","componentDidRender","firstOption","ionChange","setFocus","connectedCallback","mode","getIonMode","createColorClasses","name","pickerColumnOptionIosCss","IonPickerColumnOptionIosStyle0","pickerColumnOptionMdCss","IonPickerColumnOptionMdStyle0","PickerColumnOption","pickerColumn","onAriaLabelChange","ariaLbl","inheritedAttributes","inheritAttributes","disconnectedCallback","componentDidLoad"],"sources":["node_modules/@ionic/core/dist/collection/components/picker/picker.ios.css?tag=ion-picker&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/picker/picker.md.css?tag=ion-picker&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/picker/picker.js","node_modules/@ionic/core/dist/collection/components/picker-column/picker-column.css?tag=ion-picker-column&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/picker-column/picker-column.js","node_modules/@ionic/core/dist/collection/components/picker-column-option/picker-column-option.ios.css?tag=ion-picker-column-option&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/picker-column-option/picker-column-option.md.css?tag=ion-picker-column-option&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/picker-column-option/picker-column-option.js"],"sourcesContent":["/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n  * @prop --highlight-background: Background of the picker highlight for the selected item\n  * @prop --highlight-border-radius: Border radius of the picker highlight for the selected item\n  *\n  * @prop --fade-background-rgb: Background of the gradient covering non-selected items in rgb format\n  */\n  display: flex;\n  position: relative;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 200px;\n  /**\n   * Picker columns should display\n   * in the order in which developers\n   * added them and should ignore\n   * LTR vs RTL directions.\n   */\n  direction: ltr;\n  /**\n   * This is required otherwise the\n   * highlight will appear behind\n   * the picker when used inline.\n   */\n  z-index: 0;\n}\n\n:host .picker-before,\n:host .picker-after {\n  position: absolute;\n  width: 100%;\n  /**\n   * The transform and z-index\n   * are needed for WebKit otherwise\n   * the fade will appear underneath the picker.\n   */\n  transform: translateZ(0);\n  z-index: 1;\n  pointer-events: none;\n}\n\n:host .picker-before {\n  top: 0;\n  height: 83px;\n}\n:host .picker-before {\n  inset-inline-start: 0;\n}\n\n:host .picker-after {\n  top: 116px;\n  height: 84px;\n}\n:host .picker-after {\n  inset-inline-start: 0;\n}\n\n:host .picker-highlight {\n  border-radius: var(--highlight-border-radius, 8px);\n  left: 0;\n  right: 0;\n  top: 50%;\n  bottom: 0;\n  -webkit-margin-start: auto;\n  margin-inline-start: auto;\n  -webkit-margin-end: auto;\n  margin-inline-end: auto;\n  margin-top: 0;\n  margin-bottom: 0;\n  position: absolute;\n  width: calc(100% - 16px);\n  height: 34px;\n  transform: translateY(-50%);\n  background: var(--highlight-background);\n  z-index: -1;\n}\n\n:host input {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  outline: 0;\n  clip: rect(0 0 0 0);\n  opacity: 0;\n  overflow: hidden;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n}\n\n:host ::slotted(ion-picker-column:first-of-type) {\n  text-align: start;\n}\n\n:host ::slotted(ion-picker-column:last-of-type) {\n  text-align: end;\n}\n\n:host ::slotted(ion-picker-column:only-child) {\n  text-align: center;\n}\n\n:host .picker-before {\n  background: linear-gradient(to bottom, rgba(var(--fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 1) 20%, rgba(var(--fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 0.8) 100%);\n}\n\n:host .picker-after {\n  background: linear-gradient(to top, rgba(var(--fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 1) 20%, rgba(var(--fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 0.8) 100%);\n}\n\n:host .picker-highlight {\n  background: var(--highlight-background, var(--ion-color-step-150, var(--ion-background-color-step-150, #eeeeef)));\n}","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n  * @prop --highlight-background: Background of the picker highlight for the selected item\n  * @prop --highlight-border-radius: Border radius of the picker highlight for the selected item\n  *\n  * @prop --fade-background-rgb: Background of the gradient covering non-selected items in rgb format\n  */\n  display: flex;\n  position: relative;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 200px;\n  /**\n   * Picker columns should display\n   * in the order in which developers\n   * added them and should ignore\n   * LTR vs RTL directions.\n   */\n  direction: ltr;\n  /**\n   * This is required otherwise the\n   * highlight will appear behind\n   * the picker when used inline.\n   */\n  z-index: 0;\n}\n\n:host .picker-before,\n:host .picker-after {\n  position: absolute;\n  width: 100%;\n  /**\n   * The transform and z-index\n   * are needed for WebKit otherwise\n   * the fade will appear underneath the picker.\n   */\n  transform: translateZ(0);\n  z-index: 1;\n  pointer-events: none;\n}\n\n:host .picker-before {\n  top: 0;\n  height: 83px;\n}\n:host .picker-before {\n  inset-inline-start: 0;\n}\n\n:host .picker-after {\n  top: 116px;\n  height: 84px;\n}\n:host .picker-after {\n  inset-inline-start: 0;\n}\n\n:host .picker-highlight {\n  border-radius: var(--highlight-border-radius, 8px);\n  left: 0;\n  right: 0;\n  top: 50%;\n  bottom: 0;\n  -webkit-margin-start: auto;\n  margin-inline-start: auto;\n  -webkit-margin-end: auto;\n  margin-inline-end: auto;\n  margin-top: 0;\n  margin-bottom: 0;\n  position: absolute;\n  width: calc(100% - 16px);\n  height: 34px;\n  transform: translateY(-50%);\n  background: var(--highlight-background);\n  z-index: -1;\n}\n\n:host input {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  outline: 0;\n  clip: rect(0 0 0 0);\n  opacity: 0;\n  overflow: hidden;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n}\n\n:host ::slotted(ion-picker-column:first-of-type) {\n  text-align: start;\n}\n\n:host ::slotted(ion-picker-column:last-of-type) {\n  text-align: end;\n}\n\n:host ::slotted(ion-picker-column:only-child) {\n  text-align: center;\n}\n\n:host .picker-before {\n  background: linear-gradient(to bottom, rgba(var(--fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 1) 20%, rgba(var(--fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 0) 90%);\n}\n\n:host .picker-after {\n  background: linear-gradient(to top, rgba(var(--fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 1) 30%, rgba(var(--fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 0) 90%);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from \"@stencil/core\";\nimport { getElementRoot } from \"../../utils/helpers\";\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n */\nexport class Picker {\n    constructor() {\n        this.useInputMode = false;\n        this.isInHighlightBounds = (ev) => {\n            const { highlightEl } = this;\n            if (!highlightEl) {\n                return false;\n            }\n            const bbox = highlightEl.getBoundingClientRect();\n            /**\n             * Check to see if the user clicked\n             * outside the bounds of the highlight.\n             */\n            const outsideX = ev.clientX < bbox.left || ev.clientX > bbox.right;\n            const outsideY = ev.clientY < bbox.top || ev.clientY > bbox.bottom;\n            if (outsideX || outsideY) {\n                return false;\n            }\n            return true;\n        };\n        /**\n         * If we are no longer focused\n         * on a picker column, then we should\n         * exit input mode. An exception is made\n         * for the input in the picker since having\n         * that focused means we are still in input mode.\n         */\n        this.onFocusOut = (ev) => {\n            // TODO(FW-2832): type\n            const { relatedTarget } = ev;\n            if (!relatedTarget || (relatedTarget.tagName !== 'ION-PICKER-COLUMN' && relatedTarget !== this.inputEl)) {\n                this.exitInputMode();\n            }\n        };\n        /**\n         * When picker columns receive focus\n         * the parent picker needs to determine\n         * whether to enter/exit input mode.\n         */\n        this.onFocusIn = (ev) => {\n            // TODO(FW-2832): type\n            const { target } = ev;\n            /**\n             * Due to browser differences in how/when focus\n             * is dispatched on certain elements, we need to\n             * make sure that this function only ever runs when\n             * focusing a picker column.\n             */\n            if (target.tagName !== 'ION-PICKER-COLUMN') {\n                return;\n            }\n            /**\n             * If we have actionOnClick\n             * then this means the user focused\n             * a picker column via mouse or\n             * touch (i.e. a PointerEvent). As a result,\n             * we should not enter/exit input mode\n             * until the click event has fired, which happens\n             * after the `focusin` event.\n             *\n             * Otherwise, the user likely focused\n             * the column using their keyboard and\n             * we should enter/exit input mode automatically.\n             */\n            if (!this.actionOnClick) {\n                const columnEl = target;\n                const allowInput = columnEl.numericInput;\n                if (allowInput) {\n                    this.enterInputMode(columnEl, false);\n                }\n                else {\n                    this.exitInputMode();\n                }\n            }\n        };\n        /**\n         * On click we need to run an actionOnClick\n         * function that has been set in onPointerDown\n         * so that we enter/exit input mode correctly.\n         */\n        this.onClick = () => {\n            const { actionOnClick } = this;\n            if (actionOnClick) {\n                actionOnClick();\n                this.actionOnClick = undefined;\n            }\n        };\n        /**\n         * Clicking a column also focuses the column on\n         * certain browsers, so we use onPointerDown\n         * to tell the onFocusIn function that users\n         * are trying to click the column rather than\n         * focus the column using the keyboard. When the\n         * user completes the click, the onClick function\n         * runs and runs the actionOnClick callback.\n         */\n        this.onPointerDown = (ev) => {\n            const { useInputMode, inputModeColumn, el } = this;\n            if (this.isInHighlightBounds(ev)) {\n                /**\n                 * If we were already in\n                 * input mode, then we should determine\n                 * if we tapped a particular column and\n                 * should switch to input mode for\n                 * that specific column.\n                 */\n                if (useInputMode) {\n                    /**\n                     * If we tapped a picker column\n                     * then we should either switch to input\n                     * mode for that column or all columns.\n                     * Otherwise we should exit input mode\n                     * since we just tapped the highlight and\n                     * not a column.\n                     */\n                    if (ev.target.tagName === 'ION-PICKER-COLUMN') {\n                        /**\n                         * If user taps 2 different columns\n                         * then we should just switch to input mode\n                         * for the new column rather than switching to\n                         * input mode for all columns.\n                         */\n                        if (inputModeColumn && inputModeColumn === ev.target) {\n                            this.actionOnClick = () => {\n                                this.enterInputMode();\n                            };\n                        }\n                        else {\n                            this.actionOnClick = () => {\n                                this.enterInputMode(ev.target);\n                            };\n                        }\n                    }\n                    else {\n                        this.actionOnClick = () => {\n                            this.exitInputMode();\n                        };\n                    }\n                    /**\n                     * If we were not already in\n                     * input mode, then we should\n                     * enter input mode for all columns.\n                     */\n                }\n                else {\n                    /**\n                     * If there is only 1 numeric input column\n                     * then we should skip multi column input.\n                     */\n                    const columns = el.querySelectorAll('ion-picker-column.picker-column-numeric-input');\n                    const columnEl = columns.length === 1 ? ev.target : undefined;\n                    this.actionOnClick = () => {\n                        this.enterInputMode(columnEl);\n                    };\n                }\n                return;\n            }\n            this.actionOnClick = () => {\n                this.exitInputMode();\n            };\n        };\n        /**\n         * Enters input mode to allow\n         * for text entry of numeric values.\n         * If on mobile, we focus a hidden input\n         * field so that the on screen keyboard\n         * is brought up. When tabbing using a\n         * keyboard, picker columns receive an outline\n         * to indicate they are focused. As a result,\n         * we should not focus the hidden input as it\n         * would cause the outline to go away, preventing\n         * users from having any visual indication of which\n         * column is focused.\n         */\n        this.enterInputMode = (columnEl, focusInput = true) => {\n            const { inputEl, el } = this;\n            if (!inputEl) {\n                return;\n            }\n            /**\n             * Only active input mode if there is at\n             * least one column that accepts numeric input.\n             */\n            const hasInputColumn = el.querySelector('ion-picker-column.picker-column-numeric-input');\n            if (!hasInputColumn) {\n                return;\n            }\n            /**\n             * If columnEl is undefined then\n             * it is assumed that all numeric pickers\n             * are eligible for text entry.\n             * (i.e. hour and minute columns)\n             */\n            this.useInputMode = true;\n            this.inputModeColumn = columnEl;\n            /**\n             * Users with a keyboard and mouse can\n             * activate input mode where the input is\n             * focused as well as when it is not focused,\n             * so we need to make sure we clean up any\n             * old listeners.\n             */\n            if (focusInput) {\n                if (this.destroyKeypressListener) {\n                    this.destroyKeypressListener();\n                    this.destroyKeypressListener = undefined;\n                }\n                inputEl.focus();\n            }\n            else {\n                // TODO FW-5900 Use keydown instead\n                el.addEventListener('keypress', this.onKeyPress);\n                this.destroyKeypressListener = () => {\n                    el.removeEventListener('keypress', this.onKeyPress);\n                };\n            }\n            this.emitInputModeChange();\n        };\n        this.onKeyPress = (ev) => {\n            const { inputEl } = this;\n            if (!inputEl) {\n                return;\n            }\n            const parsedValue = parseInt(ev.key, 10);\n            /**\n             * Only numbers should be allowed\n             */\n            if (!Number.isNaN(parsedValue)) {\n                inputEl.value += ev.key;\n                this.onInputChange();\n            }\n        };\n        this.selectSingleColumn = () => {\n            const { inputEl, inputModeColumn, singleColumnSearchTimeout } = this;\n            if (!inputEl || !inputModeColumn) {\n                return;\n            }\n            const options = Array.from(inputModeColumn.querySelectorAll('ion-picker-column-option')).filter((el) => el.disabled !== true);\n            /**\n             * If users pause for a bit, the search\n             * value should be reset similar to how a\n             * <select> behaves. So typing \"34\", waiting,\n             * then typing \"5\" should select \"05\".\n             */\n            if (singleColumnSearchTimeout) {\n                clearTimeout(singleColumnSearchTimeout);\n            }\n            this.singleColumnSearchTimeout = setTimeout(() => {\n                inputEl.value = '';\n                this.singleColumnSearchTimeout = undefined;\n            }, 1000);\n            /**\n             * For values that are longer than 2 digits long\n             * we should shift the value over 1 character\n             * to the left. So typing \"456\" would result in \"56\".\n             * TODO: If we want to support more than just\n             * time entry, we should update this value to be\n             * the max length of all of the picker items.\n             */\n            if (inputEl.value.length >= 3) {\n                const startIndex = inputEl.value.length - 2;\n                const newString = inputEl.value.substring(startIndex);\n                inputEl.value = newString;\n                this.selectSingleColumn();\n                return;\n            }\n            /**\n             * Checking the value of the input gets priority\n             * first. For example, if the value of the input\n             * is \"1\" and we entered \"2\", then the complete value\n             * is \"12\" and we should select hour 12.\n             *\n             * Regex removes any leading zeros from values like \"02\",\n             * but it keeps a single zero if there are only zeros in the string.\n             * 0+(?=[1-9]) --> Match 1 or more zeros that are followed by 1-9\n             * 0+(?=0$) --> Match 1 or more zeros that must be followed by one 0 and end.\n             */\n            const findItemFromCompleteValue = options.find(({ textContent }) => {\n                /**\n                 * Keyboard entry is currently only used inside of Datetime\n                 * where we guarantee textContent is set.\n                 * If we end up exposing this feature publicly we should revisit this assumption.\n                 */\n                const parsedText = textContent.replace(/^0+(?=[1-9])|0+(?=0$)/, '');\n                return parsedText === inputEl.value;\n            });\n            if (findItemFromCompleteValue) {\n                inputModeColumn.setValue(findItemFromCompleteValue.value);\n                return;\n            }\n            /**\n             * If we typed \"56\" to get minute 56, then typed \"7\",\n             * we should select \"07\" as \"567\" is not a valid minute.\n             */\n            if (inputEl.value.length === 2) {\n                const changedCharacter = inputEl.value.substring(inputEl.value.length - 1);\n                inputEl.value = changedCharacter;\n                this.selectSingleColumn();\n            }\n        };\n        /**\n         * Searches a list of column items for a particular\n         * value. This is currently used for numeric values.\n         * The zeroBehavior can be set to account for leading\n         * or trailing zeros when looking at the item text.\n         */\n        this.searchColumn = (colEl, value, zeroBehavior = 'start') => {\n            const behavior = zeroBehavior === 'start' ? /^0+/ : /0$/;\n            const option = Array.from(colEl.querySelectorAll('ion-picker-column-option')).find((el) => {\n                return el.disabled !== true && el.textContent.replace(behavior, '') === value;\n            });\n            if (option) {\n                colEl.setValue(option.value);\n            }\n        };\n        this.selectMultiColumn = () => {\n            const { inputEl, el } = this;\n            if (!inputEl) {\n                return;\n            }\n            const numericPickers = Array.from(el.querySelectorAll('ion-picker-column')).filter((col) => col.numericInput);\n            const firstColumn = numericPickers[0];\n            const lastColumn = numericPickers[1];\n            let value = inputEl.value;\n            let minuteValue;\n            switch (value.length) {\n                case 1:\n                    this.searchColumn(firstColumn, value);\n                    break;\n                case 2:\n                    /**\n                     * If the first character is `0` or `1` it is\n                     * possible that users are trying to type `09`\n                     * or `11` into the hour field, so we should look\n                     * at that first.\n                     */\n                    const firstCharacter = inputEl.value.substring(0, 1);\n                    value = firstCharacter === '0' || firstCharacter === '1' ? inputEl.value : firstCharacter;\n                    this.searchColumn(firstColumn, value);\n                    /**\n                     * If only checked the first value,\n                     * we can check the second value\n                     * for a match in the minutes column\n                     */\n                    if (value.length === 1) {\n                        minuteValue = inputEl.value.substring(inputEl.value.length - 1);\n                        this.searchColumn(lastColumn, minuteValue, 'end');\n                    }\n                    break;\n                case 3:\n                    /**\n                     * If the first character is `0` or `1` it is\n                     * possible that users are trying to type `09`\n                     * or `11` into the hour field, so we should look\n                     * at that first.\n                     */\n                    const firstCharacterAgain = inputEl.value.substring(0, 1);\n                    value =\n                        firstCharacterAgain === '0' || firstCharacterAgain === '1'\n                            ? inputEl.value.substring(0, 2)\n                            : firstCharacterAgain;\n                    this.searchColumn(firstColumn, value);\n                    /**\n                     * If only checked the first value,\n                     * we can check the second value\n                     * for a match in the minutes column\n                     */\n                    minuteValue = value.length === 1 ? inputEl.value.substring(1) : inputEl.value.substring(2);\n                    this.searchColumn(lastColumn, minuteValue, 'end');\n                    break;\n                case 4:\n                    /**\n                     * If the first character is `0` or `1` it is\n                     * possible that users are trying to type `09`\n                     * or `11` into the hour field, so we should look\n                     * at that first.\n                     */\n                    const firstCharacterAgainAgain = inputEl.value.substring(0, 1);\n                    value =\n                        firstCharacterAgainAgain === '0' || firstCharacterAgainAgain === '1'\n                            ? inputEl.value.substring(0, 2)\n                            : firstCharacterAgainAgain;\n                    this.searchColumn(firstColumn, value);\n                    /**\n                     * If only checked the first value,\n                     * we can check the second value\n                     * for a match in the minutes column\n                     */\n                    const minuteValueAgain = value.length === 1\n                        ? inputEl.value.substring(1, inputEl.value.length)\n                        : inputEl.value.substring(2, inputEl.value.length);\n                    this.searchColumn(lastColumn, minuteValueAgain, 'end');\n                    break;\n                default:\n                    const startIndex = inputEl.value.length - 4;\n                    const newString = inputEl.value.substring(startIndex);\n                    inputEl.value = newString;\n                    this.selectMultiColumn();\n                    break;\n            }\n        };\n        /**\n         * Searches the value of the active column\n         * to determine which value users are trying\n         * to select\n         */\n        this.onInputChange = () => {\n            const { useInputMode, inputEl, inputModeColumn } = this;\n            if (!useInputMode || !inputEl) {\n                return;\n            }\n            if (inputModeColumn) {\n                this.selectSingleColumn();\n            }\n            else {\n                this.selectMultiColumn();\n            }\n        };\n        /**\n         * Emit ionInputModeChange. Picker columns\n         * listen for this event to determine whether\n         * or not their column is \"active\" for text input.\n         */\n        this.emitInputModeChange = () => {\n            const { useInputMode, inputModeColumn } = this;\n            this.ionInputModeChange.emit({\n                useInputMode,\n                inputModeColumn,\n            });\n        };\n    }\n    /**\n     * When the picker is interacted with\n     * we need to prevent touchstart so other\n     * gestures do not fire. For example,\n     * scrolling on the wheel picker\n     * in ion-datetime should not cause\n     * a card modal to swipe to close.\n     */\n    preventTouchStartPropagation(ev) {\n        ev.stopPropagation();\n    }\n    componentWillLoad() {\n        getElementRoot(this.el).addEventListener('focusin', this.onFocusIn);\n        getElementRoot(this.el).addEventListener('focusout', this.onFocusOut);\n    }\n    /**\n     * @internal\n     * Exits text entry mode for the picker\n     * This method blurs the hidden input\n     * and cause the keyboard to dismiss.\n     */\n    async exitInputMode() {\n        const { inputEl, useInputMode } = this;\n        if (!useInputMode || !inputEl) {\n            return;\n        }\n        this.useInputMode = false;\n        this.inputModeColumn = undefined;\n        inputEl.blur();\n        inputEl.value = '';\n        if (this.destroyKeypressListener) {\n            this.destroyKeypressListener();\n            this.destroyKeypressListener = undefined;\n        }\n        this.emitInputModeChange();\n    }\n    render() {\n        return (h(Host, { key: '02b0687b1f80ba295a965dfba76dd59e2d1de5d3', onPointerDown: (ev) => this.onPointerDown(ev), onClick: () => this.onClick() }, h(\"input\", { key: 'f83ed84bcf9e02539c00d8a4e63e6a0d7fc4ac71', \"aria-hidden\": \"true\", tabindex: -1, inputmode: \"numeric\", type: \"number\", onKeyDown: (ev) => {\n                var _a;\n                /**\n                 * The \"Enter\" key represents\n                 * the user submitting their time\n                 * selection, so we should blur the\n                 * input (and therefore close the keyboard)\n                 *\n                 * Updating the picker's state to no longer\n                 * be in input mode is handled in the onBlur\n                 * callback below.\n                 */\n                if (ev.key === 'Enter') {\n                    (_a = this.inputEl) === null || _a === void 0 ? void 0 : _a.blur();\n                }\n            }, ref: (el) => (this.inputEl = el), onInput: () => this.onInputChange(), onBlur: () => this.exitInputMode() }), h(\"div\", { key: '45b07fb0617d8e006712776bf78302288edb3ff4', class: \"picker-before\" }), h(\"div\", { key: '73009229368e0d62b09c913aacade26f068a7aa9', class: \"picker-after\" }), h(\"div\", { key: 'b73da00e446cd1cfd511c39212e14a00d355752e', class: \"picker-highlight\", ref: (el) => (this.highlightEl = el) }), h(\"slot\", { key: 'd969f5efc5ddb9eda6c4828702efd1ceeb69f767' })));\n    }\n    static get is() { return \"ion-picker\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"ios\": [\"picker.ios.scss\"],\n            \"md\": [\"picker.md.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"ios\": [\"picker.ios.css\"],\n            \"md\": [\"picker.md.css\"]\n        };\n    }\n    static get events() {\n        return [{\n                \"method\": \"ionInputModeChange\",\n                \"name\": \"ionInputModeChange\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"\"\n                },\n                \"complexType\": {\n                    \"original\": \"PickerChangeEventDetail\",\n                    \"resolved\": \"PickerChangeEventDetail\",\n                    \"references\": {\n                        \"PickerChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./picker-interfaces\",\n                            \"id\": \"src/components/picker/picker-interfaces.ts::PickerChangeEventDetail\"\n                        }\n                    }\n                }\n            }];\n    }\n    static get methods() {\n        return {\n            \"exitInputMode\": {\n                \"complexType\": {\n                    \"signature\": \"() => Promise<void>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<void>\"\n                },\n                \"docs\": {\n                    \"text\": \"\",\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": \"Exits text entry mode for the picker\\nThis method blurs the hidden input\\nand cause the keyboard to dismiss.\"\n                        }]\n                }\n            }\n        };\n    }\n    static get elementRef() { return \"el\"; }\n    static get listeners() {\n        return [{\n                \"name\": \"touchstart\",\n                \"method\": \"preventTouchStartPropagation\",\n                \"target\": undefined,\n                \"capture\": false,\n                \"passive\": true\n            }];\n    }\n}\n","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  display: flex;\n  position: relative;\n  align-items: center;\n  justify-content: center;\n  max-width: 100%;\n  height: 200px;\n  font-size: 22px;\n  text-align: center;\n}\n\n/**\n * Renders an invisible element on top of the column that receives focus\n * events. This allows screen readers to navigate the column.\n */\n.assistive-focusable {\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  position: absolute;\n  z-index: 1;\n  pointer-events: none;\n}\n\n.assistive-focusable:focus {\n  outline: none;\n}\n\n.picker-opts {\n  /**\n   * This padding must be set here and not on the\n   * host to ensure that the focus highlight on the\n   * column is not overly narrow.\n   */\n  -webkit-padding-start: 16px;\n  padding-inline-start: 16px;\n  -webkit-padding-end: 16px;\n  padding-inline-end: 16px;\n  padding-top: 0px;\n  padding-bottom: 0px;\n  /**\n   * When using reactive data, such as in datetime's\n   * wheel picker, there may be layout shifts between\n   * individual columns in a picker as the columns\n   * shrink to fit the widest item in the column.\n   * Setting a minimum width avoids this layout shifting.\n   *\n   * Note that we need this min-width set on the same\n   * element as the vertical padding (i.e. not on the\n   * host).\n   */\n  min-width: 26px;\n  max-height: 200px;\n  outline: none;\n  /**\n   * Added so that text-align can be set on the host\n   * from external components. For example, datetime\n   * changes the alignment of specific columns in its\n   * wheel pickers.\n   */\n  text-align: inherit;\n  scroll-snap-type: y mandatory;\n  /**\n   * Need to explicitly set overflow-x: hidden\n   * for older implementations of scroll snapping.\n   */\n  overflow-x: hidden;\n  overflow-y: scroll;\n  scrollbar-width: none;\n}\n\n.picker-item-empty {\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n  display: block;\n  width: 100%;\n  height: 34px;\n  border: 0px;\n  outline: none;\n  background: transparent;\n  color: inherit;\n  font-family: var(--ion-font-family, inherit);\n  font-size: inherit;\n  line-height: 34px;\n  text-align: inherit;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n\n/**\n * Hide scrollbars on Chrome and Safari\n */\n.picker-opts::-webkit-scrollbar {\n  display: none;\n}\n\n::slotted(ion-picker-column-option) {\n  display: block;\n  scroll-snap-align: center;\n}\n\n.picker-item-empty,\n:host(:not([disabled])) ::slotted(ion-picker-column-option.option-disabled) {\n  scroll-snap-align: none;\n}\n\n::slotted([slot=prefix]), ::slotted([slot=suffix]) {\n  max-width: 200px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n\n::slotted([slot=prefix]) {\n  /**\n   * This is added in addition to the column's own padding so that there is white\n   * space between the slot and the column's focus highlight.\n   */\n  -webkit-padding-start: 16px;\n  padding-inline-start: 16px;\n  -webkit-padding-end: 16px;\n  padding-inline-end: 16px;\n  padding-top: 0;\n  padding-bottom: 0;\n  justify-content: end;\n}\n\n::slotted([slot=suffix]) {\n  /**\n   * This is added in addition to the column's own padding so that there is white\n   * space between the slot and the column's focus highlight.\n   */\n  -webkit-padding-start: 16px;\n  padding-inline-start: 16px;\n  -webkit-padding-end: 16px;\n  padding-inline-end: 16px;\n  padding-top: 0;\n  padding-bottom: 0;\n  justify-content: start;\n}\n\n:host(.picker-column-disabled) .picker-opts {\n  overflow-y: hidden;\n}\n\n/**\n * When the column is disabled, none of the options\n * should be interactive. However, we do not disable\n * the buttons because that would require overriding the\n * app's preference for each option. In this case,\n * the picker column interactive as a whole is\n * disabled, not individual options.\n */\n:host(.picker-column-disabled) ::slotted(ion-picker-column-option) {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n}\n\n@media (any-hover: hover) {\n  :host(:focus) .picker-opts {\n    outline: none;\n    background: rgba(var(--ion-color-base-rgb), 0.2);\n  }\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from \"@stencil/core\";\nimport { doc } from \"../../utils/browser/index\";\nimport { getElementRoot, raf } from \"../../utils/helpers\";\nimport { hapticSelectionChanged, hapticSelectionEnd, hapticSelectionStart } from \"../../utils/native/haptic\";\nimport { isPlatform } from \"../../utils/platform\";\nimport { createColorClasses } from \"../../utils/theme\";\nimport { getIonMode } from \"../../global/ionic-global\";\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n *\n * @slot prefix - Content to show on the left side of the picker options.\n * @slot suffix - Content to show on the right side of the picker options.\n */\nexport class PickerColumn {\n    constructor() {\n        this.isScrolling = false;\n        this.isColumnVisible = false;\n        this.canExitInputMode = true;\n        this.updateValueTextOnScroll = false;\n        this.centerPickerItemInView = (target, smooth = true, canExitInputMode = true) => {\n            const { isColumnVisible, scrollEl } = this;\n            if (isColumnVisible && scrollEl) {\n                // (Vertical offset from parent) - (three empty picker rows) + (half the height of the target to ensure the scroll triggers)\n                const top = target.offsetTop - 3 * target.clientHeight + target.clientHeight / 2;\n                if (scrollEl.scrollTop !== top) {\n                    /**\n                     * Setting this flag prevents input\n                     * mode from exiting in the picker column's\n                     * scroll callback. This is useful when the user manually\n                     * taps an item or types on the keyboard as both\n                     * of these can cause a scroll to occur.\n                     */\n                    this.canExitInputMode = canExitInputMode;\n                    this.updateValueTextOnScroll = false;\n                    scrollEl.scroll({\n                        top,\n                        left: 0,\n                        behavior: smooth ? 'smooth' : undefined,\n                    });\n                }\n            }\n        };\n        this.setPickerItemActiveState = (item, isActive) => {\n            if (isActive) {\n                item.classList.add(PICKER_ITEM_ACTIVE_CLASS);\n            }\n            else {\n                item.classList.remove(PICKER_ITEM_ACTIVE_CLASS);\n            }\n        };\n        /**\n         * When ionInputModeChange is emitted, each column\n         * needs to check if it is the one being made available\n         * for text entry.\n         */\n        this.inputModeChange = (ev) => {\n            if (!this.numericInput) {\n                return;\n            }\n            const { useInputMode, inputModeColumn } = ev.detail;\n            /**\n             * If inputModeColumn is undefined then this means\n             * all numericInput columns are being selected.\n             */\n            const isColumnActive = inputModeColumn === undefined || inputModeColumn === this.el;\n            if (!useInputMode || !isColumnActive) {\n                this.setInputModeActive(false);\n                return;\n            }\n            this.setInputModeActive(true);\n        };\n        /**\n         * Setting isActive will cause a re-render.\n         * As a result, we do not want to cause the\n         * re-render mid scroll as this will cause\n         * the picker column to jump back to\n         * whatever value was selected at the\n         * start of the scroll interaction.\n         */\n        this.setInputModeActive = (state) => {\n            if (this.isScrolling) {\n                this.scrollEndCallback = () => {\n                    this.isActive = state;\n                };\n                return;\n            }\n            this.isActive = state;\n        };\n        /**\n         * When the column scrolls, the component\n         * needs to determine which item is centered\n         * in the view and will emit an ionChange with\n         * the item object.\n         */\n        this.initializeScrollListener = () => {\n            /**\n             * The haptics for the wheel picker are\n             * an iOS-only feature. As a result, they should\n             * be disabled on Android.\n             */\n            const enableHaptics = isPlatform('ios');\n            const { el, scrollEl } = this;\n            let timeout;\n            let activeEl = this.activeItem;\n            const scrollCallback = () => {\n                raf(() => {\n                    var _a;\n                    if (!scrollEl)\n                        return;\n                    if (timeout) {\n                        clearTimeout(timeout);\n                        timeout = undefined;\n                    }\n                    if (!this.isScrolling) {\n                        enableHaptics && hapticSelectionStart();\n                        this.isScrolling = true;\n                    }\n                    /**\n                     * Select item in the center of the column\n                     * which is the month/year that we want to select\n                     */\n                    const bbox = scrollEl.getBoundingClientRect();\n                    const centerX = bbox.x + bbox.width / 2;\n                    const centerY = bbox.y + bbox.height / 2;\n                    /**\n                     * elementFromPoint returns the top-most element.\n                     * This means that if an ion-backdrop is overlaying the\n                     * picker then the appropriate picker column option will\n                     * not be selected. To account for this, we use elementsFromPoint\n                     * and use an Array.find to find the appropriate column option\n                     * at that point.\n                     *\n                     * Additionally, the picker column could be used in the\n                     * Shadow DOM (i.e. in ion-datetime) so we need to make\n                     * sure we are choosing the correct host otherwise\n                     * the elements returns by elementsFromPoint will be\n                     * retargeted. To account for this, we check to see\n                     * if the picker column has a parent shadow root. If\n                     * so, we use that shadow root when doing elementsFromPoint.\n                     * Otherwise, we just use the document.\n                     */\n                    const rootNode = el.getRootNode();\n                    const hasParentShadow = rootNode instanceof ShadowRoot;\n                    const referenceNode = hasParentShadow ? rootNode : doc;\n                    /**\n                     * If the reference node is undefined\n                     * then it's likely that doc is undefined\n                     * due to being in an SSR environment.\n                     */\n                    if (referenceNode === undefined) {\n                        return;\n                    }\n                    const elementsAtPoint = referenceNode.elementsFromPoint(centerX, centerY);\n                    /**\n                     * elementsFromPoint can returns multiple elements\n                     * so find the relevant picker column option if one exists.\n                     */\n                    const newActiveElement = elementsAtPoint.find((el) => el.tagName === 'ION-PICKER-COLUMN-OPTION');\n                    if (activeEl !== undefined) {\n                        this.setPickerItemActiveState(activeEl, false);\n                    }\n                    if (newActiveElement === undefined || newActiveElement.disabled) {\n                        return;\n                    }\n                    /**\n                     * If we are selecting a new value,\n                     * we need to run haptics again.\n                     */\n                    if (newActiveElement !== activeEl) {\n                        enableHaptics && hapticSelectionChanged();\n                        if (this.canExitInputMode) {\n                            /**\n                             * The native iOS wheel picker\n                             * only dismisses the keyboard\n                             * once the selected item has changed\n                             * as a result of a swipe\n                             * from the user. If `canExitInputMode` is\n                             * `false` then this means that the\n                             * scroll is happening as a result of\n                             * the `value` property programmatically changing\n                             * either by an application or by the user via the keyboard.\n                             */\n                            this.exitInputMode();\n                        }\n                    }\n                    activeEl = newActiveElement;\n                    this.setPickerItemActiveState(newActiveElement, true);\n                    /**\n                     * Set the aria-valuetext even though the value prop has not been updated yet.\n                     * This enables some screen readers to announce the value as the users drag\n                     * as opposed to when their release their pointer from the screen.\n                     *\n                     * When the value is programmatically updated, we will smoothly scroll\n                     * to the new option. However, we do not want to update aria-valuetext mid-scroll\n                     * as that can cause the old value to be briefly set before being set to the\n                     * correct option. This will cause some screen readers to announce the old value\n                     * again before announcing the new value. The correct valuetext will be set on render.\n                     */\n                    if (this.updateValueTextOnScroll) {\n                        (_a = this.assistiveFocusable) === null || _a === void 0 ? void 0 : _a.setAttribute('aria-valuetext', this.getOptionValueText(newActiveElement));\n                    }\n                    timeout = setTimeout(() => {\n                        this.isScrolling = false;\n                        this.updateValueTextOnScroll = true;\n                        enableHaptics && hapticSelectionEnd();\n                        /**\n                         * Certain tasks (such as those that\n                         * cause re-renders) should only be done\n                         * once scrolling has finished, otherwise\n                         * flickering may occur.\n                         */\n                        const { scrollEndCallback } = this;\n                        if (scrollEndCallback) {\n                            scrollEndCallback();\n                            this.scrollEndCallback = undefined;\n                        }\n                        /**\n                         * Reset this flag as the\n                         * next scroll interaction could\n                         * be a scroll from the user. In this\n                         * case, we should exit input mode.\n                         */\n                        this.canExitInputMode = true;\n                        this.setValue(newActiveElement.value);\n                    }, 250);\n                });\n            };\n            /**\n             * Wrap this in an raf so that the scroll callback\n             * does not fire when component is initially shown.\n             */\n            raf(() => {\n                if (!scrollEl)\n                    return;\n                scrollEl.addEventListener('scroll', scrollCallback);\n                this.destroyScrollListener = () => {\n                    scrollEl.removeEventListener('scroll', scrollCallback);\n                };\n            });\n        };\n        /**\n         * Tells the parent picker to\n         * exit text entry mode. This is only called\n         * when the selected item changes during scroll, so\n         * we know that the user likely wants to scroll\n         * instead of type.\n         */\n        this.exitInputMode = () => {\n            const { parentEl } = this;\n            if (parentEl == null)\n                return;\n            parentEl.exitInputMode();\n            /**\n             * setInputModeActive only takes\n             * effect once scrolling stops to avoid\n             * a component re-render while scrolling.\n             * However, we want the visual active\n             * indicator to go away immediately, so\n             * we call classList.remove here.\n             */\n            this.el.classList.remove('picker-column-active');\n        };\n        /**\n         * Find the next enabled option after the active option.\n         * @param stride - How many options to \"jump\" over in order to select the next option.\n         * This can be used to implement PageUp/PageDown behaviors where pressing these keys\n         * scrolls the picker by more than 1 option. For example, a stride of 5 means select\n         * the enabled option 5 options after the active one. Note that the actual option selected\n         * may be past the stride if the option at the stride is disabled.\n         */\n        this.findNextOption = (stride = 1) => {\n            const { activeItem } = this;\n            if (!activeItem)\n                return null;\n            let prevNode = activeItem;\n            let node = activeItem.nextElementSibling;\n            while (node != null) {\n                if (stride > 0) {\n                    stride--;\n                }\n                if (node.tagName === 'ION-PICKER-COLUMN-OPTION' && !node.disabled && stride === 0) {\n                    return node;\n                }\n                prevNode = node;\n                // Use nextElementSibling instead of nextSibling to avoid text/comment nodes\n                node = node.nextElementSibling;\n            }\n            return prevNode;\n        };\n        /**\n         * Find the next enabled option after the active option.\n         * @param stride - How many options to \"jump\" over in order to select the next option.\n         * This can be used to implement PageUp/PageDown behaviors where pressing these keys\n         * scrolls the picker by more than 1 option. For example, a stride of 5 means select\n         * the enabled option 5 options before the active one. Note that the actual option selected\n         *  may be past the stride if the option at the stride is disabled.\n         */\n        this.findPreviousOption = (stride = 1) => {\n            const { activeItem } = this;\n            if (!activeItem)\n                return null;\n            let nextNode = activeItem;\n            let node = activeItem.previousElementSibling;\n            while (node != null) {\n                if (stride > 0) {\n                    stride--;\n                }\n                if (node.tagName === 'ION-PICKER-COLUMN-OPTION' && !node.disabled && stride === 0) {\n                    return node;\n                }\n                nextNode = node;\n                // Use previousElementSibling instead of previousSibling to avoid text/comment nodes\n                node = node.previousElementSibling;\n            }\n            return nextNode;\n        };\n        this.onKeyDown = (ev) => {\n            /**\n             * The below operations should be inverted when running on a mobile device.\n             * For example, swiping up will dispatch an \"ArrowUp\" event. On desktop,\n             * this should cause the previous option to be selected. On mobile, swiping\n             * up causes a view to scroll down. As a result, swiping up on mobile should\n             * cause the next option to be selected. The Home/End operations remain\n             * unchanged because those always represent the first/last options, respectively.\n             */\n            const mobile = isPlatform('mobile');\n            let newOption = null;\n            switch (ev.key) {\n                case 'ArrowDown':\n                    newOption = mobile ? this.findPreviousOption() : this.findNextOption();\n                    break;\n                case 'ArrowUp':\n                    newOption = mobile ? this.findNextOption() : this.findPreviousOption();\n                    break;\n                case 'PageUp':\n                    newOption = mobile ? this.findNextOption(5) : this.findPreviousOption(5);\n                    break;\n                case 'PageDown':\n                    newOption = mobile ? this.findPreviousOption(5) : this.findNextOption(5);\n                    break;\n                case 'Home':\n                    /**\n                     * There is no guarantee that the first child will be an ion-picker-column-option,\n                     * so we do not use firstElementChild.\n                     */\n                    newOption = this.el.querySelector('ion-picker-column-option:first-of-type');\n                    break;\n                case 'End':\n                    /**\n                     * There is no guarantee that the last child will be an ion-picker-column-option,\n                     * so we do not use lastElementChild.\n                     */\n                    newOption = this.el.querySelector('ion-picker-column-option:last-of-type');\n                    break;\n                default:\n                    break;\n            }\n            if (newOption !== null) {\n                this.value = newOption.value;\n                // This stops any default browser behavior such as scrolling\n                ev.preventDefault();\n            }\n        };\n        /**\n         * Utility to generate the correct text for aria-valuetext.\n         */\n        this.getOptionValueText = (el) => {\n            var _a;\n            return el ? (_a = el.getAttribute('aria-label')) !== null && _a !== void 0 ? _a : el.innerText : '';\n        };\n        /**\n         * Render an element that overlays the column. This element is for assistive\n         * tech to allow users to navigate the column up/down. This element should receive\n         * focus as it listens for synthesized keyboard events as required by the\n         * slider role: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/slider_role\n         */\n        this.renderAssistiveFocusable = () => {\n            const { activeItem } = this;\n            const valueText = this.getOptionValueText(activeItem);\n            /**\n             * When using the picker, the valuetext provides important context that valuenow\n             * does not. Additionally, using non-zero valuemin/valuemax values can cause\n             * WebKit to incorrectly announce numeric valuetext values (such as a year\n             * like \"2024\") as percentages: https://bugs.webkit.org/show_bug.cgi?id=273126\n             */\n            return (h(\"div\", { ref: (el) => (this.assistiveFocusable = el), class: \"assistive-focusable\", role: \"slider\", tabindex: this.disabled ? undefined : 0, \"aria-label\": this.ariaLabel, \"aria-valuemin\": 0, \"aria-valuemax\": 0, \"aria-valuenow\": 0, \"aria-valuetext\": valueText, \"aria-orientation\": \"vertical\", onKeyDown: (ev) => this.onKeyDown(ev) }));\n        };\n        this.ariaLabel = null;\n        this.isActive = false;\n        this.disabled = false;\n        this.value = undefined;\n        this.color = 'primary';\n        this.numericInput = false;\n    }\n    ariaLabelChanged(newValue) {\n        this.ariaLabel = newValue;\n    }\n    valueChange() {\n        if (this.isColumnVisible) {\n            /**\n             * Only scroll the active item into view when the picker column\n             * is actively visible to the user.\n             */\n            this.scrollActiveItemIntoView(true);\n        }\n    }\n    /**\n     * Only setup scroll listeners\n     * when the picker is visible, otherwise\n     * the container will have a scroll\n     * height of 0px.\n     */\n    componentWillLoad() {\n        /**\n         * We cache parentEl in a local variable\n         * so we don't need to keep accessing\n         * the class variable (which comes with\n         * a small performance hit)\n         */\n        const parentEl = (this.parentEl = this.el.closest('ion-picker'));\n        const visibleCallback = (entries) => {\n            /**\n             * Browsers will sometimes group multiple IO events into a single callback.\n             * As a result, we want to grab the last/most recent event in case there are multiple events.\n             */\n            const ev = entries[entries.length - 1];\n            if (ev.isIntersecting) {\n                const { activeItem, el } = this;\n                this.isColumnVisible = true;\n                /**\n                 * Because this initial call to scrollActiveItemIntoView has to fire before\n                 * the scroll listener is set up, we need to manage the active class manually.\n                 */\n                const oldActive = getElementRoot(el).querySelector(`.${PICKER_ITEM_ACTIVE_CLASS}`);\n                if (oldActive) {\n                    this.setPickerItemActiveState(oldActive, false);\n                }\n                this.scrollActiveItemIntoView();\n                if (activeItem) {\n                    this.setPickerItemActiveState(activeItem, true);\n                }\n                this.initializeScrollListener();\n            }\n            else {\n                this.isColumnVisible = false;\n                if (this.destroyScrollListener) {\n                    this.destroyScrollListener();\n                    this.destroyScrollListener = undefined;\n                }\n            }\n        };\n        /**\n         * Set the root to be the parent picker element\n         * This causes the IO callback\n         * to be fired in WebKit as soon as the element\n         * is visible. If we used the default root value\n         * then WebKit would only fire the IO callback\n         * after any animations (such as a modal transition)\n         * finished, and there would potentially be a flicker.\n         */\n        new IntersectionObserver(visibleCallback, { threshold: 0.001, root: this.parentEl }).observe(this.el);\n        if (parentEl !== null) {\n            // TODO(FW-2832): type\n            parentEl.addEventListener('ionInputModeChange', (ev) => this.inputModeChange(ev));\n        }\n    }\n    componentDidRender() {\n        const { el, activeItem, isColumnVisible, value } = this;\n        if (isColumnVisible && !activeItem) {\n            const firstOption = el.querySelector('ion-picker-column-option');\n            /**\n             * If the picker column does not have an active item and the current value\n             * does not match the first item in the picker column, that means\n             * the value is out of bounds. In this case, we assign the value to the\n             * first item to match the scroll position of the column.\n             *\n             */\n            if (firstOption !== null && firstOption.value !== value) {\n                this.setValue(firstOption.value);\n            }\n        }\n    }\n    /** @internal  */\n    async scrollActiveItemIntoView(smooth = false) {\n        const activeEl = this.activeItem;\n        if (activeEl) {\n            this.centerPickerItemInView(activeEl, smooth, false);\n        }\n    }\n    /**\n     * Sets the value prop and fires the ionChange event.\n     * This is used when we need to fire ionChange from\n     * user-generated events that cannot be caught with normal\n     * input/change event listeners.\n     * @internal\n     */\n    async setValue(value) {\n        if (this.disabled === true || this.value === value) {\n            return;\n        }\n        this.value = value;\n        this.ionChange.emit({ value });\n    }\n    /**\n     * Sets focus on the scrollable container within the picker column.\n     * Use this method instead of the global `pickerColumn.focus()`.\n     */\n    async setFocus() {\n        if (this.scrollEl) {\n            this.scrollEl.focus();\n        }\n    }\n    connectedCallback() {\n        var _a;\n        this.ariaLabel = (_a = this.el.getAttribute('aria-label')) !== null && _a !== void 0 ? _a : 'Select a value';\n    }\n    get activeItem() {\n        const { value } = this;\n        const options = Array.from(this.el.querySelectorAll('ion-picker-column-option'));\n        return options.find((option) => {\n            /**\n             * If the whole picker column is disabled, the current value should appear active\n             * If the current value item is specifically disabled, it should not appear active\n             */\n            if (!this.disabled && option.disabled) {\n                return false;\n            }\n            return option.value === value;\n        });\n    }\n    render() {\n        const { color, disabled, isActive, numericInput } = this;\n        const mode = getIonMode(this);\n        return (h(Host, { key: 'ced35afc6326a20dbac68193921a807a9c10bb99', class: createColorClasses(color, {\n                [mode]: true,\n                ['picker-column-active']: isActive,\n                ['picker-column-numeric-input']: numericInput,\n                ['picker-column-disabled']: disabled,\n            }) }, this.renderAssistiveFocusable(), h(\"slot\", { key: '41e290dcc44dacb4237eb674ce2dedc7db66eb7d', name: \"prefix\" }), h(\"div\", { key: '1fd869b063900103deadefc40929a1e8f02ec084', \"aria-hidden\": \"true\", class: \"picker-opts\", ref: (el) => {\n                this.scrollEl = el;\n            } }, h(\"div\", { key: '0d2087f775b240c9b2534650eb27f3d99e7690a9', class: \"picker-item-empty\", \"aria-hidden\": \"true\" }, \"\\u00A0\"), h(\"div\", { key: '1245b2bb2b6314c3ec4e0ab3ece4e42beb360fc9', class: \"picker-item-empty\", \"aria-hidden\": \"true\" }, \"\\u00A0\"), h(\"div\", { key: '503b08f6bbe27fa7d34c165a93ec38ce7f1ad590', class: \"picker-item-empty\", \"aria-hidden\": \"true\" }, \"\\u00A0\"), h(\"slot\", { key: 'ec401a2b2d56546fb3f10239b71320ce7dc6a77d' }), h(\"div\", { key: '97a234018291c5a6ca7a56bb1a9a417cac0b3e6f', class: \"picker-item-empty\", \"aria-hidden\": \"true\" }, \"\\u00A0\"), h(\"div\", { key: '0197711f71486a8fa3c184b593cebe1c1e54c585', class: \"picker-item-empty\", \"aria-hidden\": \"true\" }, \"\\u00A0\"), h(\"div\", { key: '961304f0a2a10afb3502ce4c5fbdceef0aa933cf', class: \"picker-item-empty\", \"aria-hidden\": \"true\" }, \"\\u00A0\")), h(\"slot\", { key: 'f38b83d26c3c2ba8ef00da7caf7f0be518b2007d', name: \"suffix\" })));\n    }\n    static get is() { return \"ion-picker-column\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"$\": [\"picker-column.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"$\": [\"picker-column.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"disabled\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the user cannot interact with the picker.\"\n                },\n                \"attribute\": \"disabled\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"value\": {\n                \"type\": \"any\",\n                \"mutable\": true,\n                \"complexType\": {\n                    \"original\": \"string | number\",\n                    \"resolved\": \"number | string | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The selected option in the picker.\"\n                },\n                \"attribute\": \"value\",\n                \"reflect\": false\n            },\n            \"color\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"Color\",\n                    \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n                    \"references\": {\n                        \"Color\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::Color\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n                },\n                \"attribute\": \"color\",\n                \"reflect\": true,\n                \"defaultValue\": \"'primary'\"\n            },\n            \"numericInput\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"If `true`, tapping the picker will\\nreveal a number input keyboard that lets\\nthe user type in values for each picker\\ncolumn. This is useful when working\\nwith time pickers.\"\n                },\n                \"attribute\": \"numeric-input\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            }\n        };\n    }\n    static get states() {\n        return {\n            \"ariaLabel\": {},\n            \"isActive\": {}\n        };\n    }\n    static get events() {\n        return [{\n                \"method\": \"ionChange\",\n                \"name\": \"ionChange\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the value has changed.\\n\\nThis event will not emit when programmatically setting the `value` property.\"\n                },\n                \"complexType\": {\n                    \"original\": \"PickerColumnChangeEventDetail\",\n                    \"resolved\": \"PickerColumnChangeEventDetail\",\n                    \"references\": {\n                        \"PickerColumnChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./picker-column-interfaces\",\n                            \"id\": \"src/components/picker-column/picker-column-interfaces.ts::PickerColumnChangeEventDetail\"\n                        }\n                    }\n                }\n            }];\n    }\n    static get methods() {\n        return {\n            \"scrollActiveItemIntoView\": {\n                \"complexType\": {\n                    \"signature\": \"(smooth?: boolean) => Promise<void>\",\n                    \"parameters\": [{\n                            \"name\": \"smooth\",\n                            \"type\": \"boolean\",\n                            \"docs\": \"\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<void>\"\n                },\n                \"docs\": {\n                    \"text\": \"\",\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }]\n                }\n            },\n            \"setValue\": {\n                \"complexType\": {\n                    \"signature\": \"(value: PickerColumnValue) => Promise<void>\",\n                    \"parameters\": [{\n                            \"name\": \"value\",\n                            \"type\": \"string | number | undefined\",\n                            \"docs\": \"\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        },\n                        \"PickerColumnValue\": {\n                            \"location\": \"import\",\n                            \"path\": \"./picker-column-interfaces\",\n                            \"id\": \"src/components/picker-column/picker-column-interfaces.ts::PickerColumnValue\"\n                        }\n                    },\n                    \"return\": \"Promise<void>\"\n                },\n                \"docs\": {\n                    \"text\": \"Sets the value prop and fires the ionChange event.\\nThis is used when we need to fire ionChange from\\nuser-generated events that cannot be caught with normal\\ninput/change event listeners.\",\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }]\n                }\n            },\n            \"setFocus\": {\n                \"complexType\": {\n                    \"signature\": \"() => Promise<void>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<void>\"\n                },\n                \"docs\": {\n                    \"text\": \"Sets focus on the scrollable container within the picker column.\\nUse this method instead of the global `pickerColumn.focus()`.\",\n                    \"tags\": []\n                }\n            }\n        };\n    }\n    static get elementRef() { return \"el\"; }\n    static get watchers() {\n        return [{\n                \"propName\": \"aria-label\",\n                \"methodName\": \"ariaLabelChanged\"\n            }, {\n                \"propName\": \"value\",\n                \"methodName\": \"valueChange\"\n            }];\n    }\n}\nconst PICKER_ITEM_ACTIVE_CLASS = 'option-active';\n","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\nbutton {\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n  width: 100%;\n  height: 34px;\n  border: 0px;\n  outline: none;\n  background: transparent;\n  color: inherit;\n  font-family: var(--ion-font-family, inherit);\n  font-size: inherit;\n  line-height: 34px;\n  text-align: inherit;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  cursor: pointer;\n  overflow: hidden;\n}\n\n:host(.option-disabled) {\n  opacity: 0.4;\n}\n\n:host(.option-disabled) button {\n  cursor: default;\n}","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\nbutton {\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n  width: 100%;\n  height: 34px;\n  border: 0px;\n  outline: none;\n  background: transparent;\n  color: inherit;\n  font-family: var(--ion-font-family, inherit);\n  font-size: inherit;\n  line-height: 34px;\n  text-align: inherit;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  cursor: pointer;\n  overflow: hidden;\n}\n\n:host(.option-disabled) {\n  opacity: 0.4;\n}\n\n:host(.option-disabled) button {\n  cursor: default;\n}\n\n:host(.option-active) {\n  color: var(--ion-color-base);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from \"@stencil/core\";\nimport { inheritAttributes } from \"../../utils/helpers\";\nimport { createColorClasses } from \"../../utils/theme\";\nimport { getIonMode } from \"../../global/ionic-global\";\nexport class PickerColumnOption {\n    constructor() {\n        /**\n         * We keep track of the parent picker column\n         * so we can update the value of it when\n         * clicking an enable option.\n         */\n        this.pickerColumn = null;\n        this.ariaLabel = null;\n        this.disabled = false;\n        this.value = undefined;\n        this.color = 'primary';\n    }\n    /**\n     * The aria-label of the option has changed after the\n     * first render and needs to be updated within the component.\n     *\n     * @param ariaLbl The new aria-label value.\n     */\n    onAriaLabelChange(ariaLbl) {\n        this.ariaLabel = ariaLbl;\n    }\n    componentWillLoad() {\n        const inheritedAttributes = inheritAttributes(this.el, ['aria-label']);\n        /**\n         * The initial value of `aria-label` needs to be set for\n         * the first render.\n    \n         */\n        this.ariaLabel = inheritedAttributes['aria-label'] || null;\n    }\n    connectedCallback() {\n        this.pickerColumn = this.el.closest('ion-picker-column');\n    }\n    disconnectedCallback() {\n        this.pickerColumn = null;\n    }\n    /**\n     * The column options can load at any time\n     * so the options needs to tell the\n     * parent picker column when it is loaded\n     * so the picker column can ensure it is\n     * centered in the view.\n     *\n     * We intentionally run this for every\n     * option. If we only ran this from\n     * the selected option then if the newly\n     * loaded options were not selected then\n     * scrollActiveItemIntoView would not be called.\n     */\n    componentDidLoad() {\n        const { pickerColumn } = this;\n        if (pickerColumn !== null) {\n            pickerColumn.scrollActiveItemIntoView();\n        }\n    }\n    /**\n     * When an option is clicked, update the\n     * parent picker column value. This\n     * component will handle centering the option\n     * in the column view.\n     */\n    onClick() {\n        const { pickerColumn } = this;\n        if (pickerColumn !== null) {\n            pickerColumn.setValue(this.value);\n        }\n    }\n    render() {\n        const { color, disabled, ariaLabel } = this;\n        const mode = getIonMode(this);\n        return (h(Host, { key: 'cc4435a0ce0e55be1321bcabaf342ed68cf5ba1e', class: createColorClasses(color, {\n                [mode]: true,\n                ['option-disabled']: disabled,\n            }) }, h(\"button\", { key: '0187fb967771e0787807a8538dce4e59f6a98565', tabindex: \"-1\", \"aria-label\": ariaLabel, disabled: disabled, onClick: () => this.onClick() }, h(\"slot\", { key: 'dbe52552f3f27332816748c12d929cc81060841d' }))));\n    }\n    static get is() { return \"ion-picker-column-option\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"ios\": [\"picker-column-option.ios.scss\"],\n            \"md\": [\"picker-column-option.md.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"ios\": [\"picker-column-option.ios.css\"],\n            \"md\": [\"picker-column-option.md.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"disabled\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the user cannot interact with the picker column option.\"\n                },\n                \"attribute\": \"disabled\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"value\": {\n                \"type\": \"any\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"any | null\",\n                    \"resolved\": \"any\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The text value of the option.\"\n                },\n                \"attribute\": \"value\",\n                \"reflect\": false\n            },\n            \"color\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"Color\",\n                    \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n                    \"references\": {\n                        \"Color\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::Color\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n                },\n                \"attribute\": \"color\",\n                \"reflect\": true,\n                \"defaultValue\": \"'primary'\"\n            }\n        };\n    }\n    static get states() {\n        return {\n            \"ariaLabel\": {}\n        };\n    }\n    static get elementRef() { return \"el\"; }\n    static get watchers() {\n        return [{\n                \"propName\": \"aria-label\",\n                \"methodName\": \"onAriaLabelChange\"\n            }];\n    }\n}\n"],"mappings":"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"}