{"version":3,"names":["focusableQueryString","focusFirstDescendant","ref","fallbackElement","firstInput","querySelector","focusElementInContext","focusLastDescendant","inputs","Array","from","querySelectorAll","lastInput","length","hostToFocus","elementToFocus","shadowRoot","focusVisibleElement","focus","lastOverlayIndex","lastId","activeAnimations","WeakMap","createController","tagName","create","options","createOverlay","dismiss","data","role","id","dismissOverlay","document","getTop","getPresentedOverlay","alertController","actionSheetController","loadingController","modalController","popoverController","toastController","prepareOverlay","el","connectListeners","overlayIndex","setOverlayId","hasAttribute","opts","window","customElements","whenDefined","then","element","createElement","classList","add","Object","assign","hasController","getAppRoot","appendChild","Promise","resolve","componentOnReady","isOverlayHidden","overlay","contains","focusElementInOverlay","trapKeyboardFocus","ev","doc","lastOverlay","target","FOCUS_TRAP_DISABLE_CLASS","trapScopedFocus","lastFocus","undefined","overlayRoot","getElementRoot","overlayWrapper","activeElement","trapShadowFocus","addEventListener","backdropDismiss","detail","register","OVERLAY_BACK_BUTTON_PRIORITY","BACKDROP","shouldUseCloseWatcher","key","overlayTag","reject","getOverlays","selector","filter","c","getPresentedOverlays","o","overlays","find","setRootAriaHidden","hidden","root","viewContainer","setAttribute","removeAttribute","present","async","name","iosEnterAnimation","mdEnterAnimation","_a","_b","presented","body","BACKDROP_NO_SCROLL","hideOverlaysFromScreenReaders","willPresent","emit","willPresentShorthand","mode","getIonMode","animationBuilder","enterAnimation","config","get","completed","overlayAnimation","didPresent","didPresentShorthand","restoreElementFocus","keyboardClose","overlayEl","previousElement","onDidDismiss","iosLeaveAnimation","mdLeaveAnimation","remove","style","setProperty","willDismiss","willDismissShorthand","leaveAnimation","GESTURE","didDismiss","didDismissShorthand","animations","forEach","ani","destroy","delete","removeProperty","err","console","error","revealOverlaysToScreenReaders","baseEl","aniRoot","animation","animated","getBoolean","duration","beforeAddWrite","ownerDocument","matches","blur","activeAni","set","play","eventMethod","eventName","promise","r","onceEvent","event","callback","handler","removeEventListener","isCancel","defaultGate","h","safeCall","arg","jmp","e","OVERLAY_GESTURE_PRIORITY","createDelegateController","inline","workingDelegate","coreDelegate","CoreDelegate","getDelegate","force","delegate","parentEl","parentNode","attachViewToDom","component","Error","removeViewFromDom","parentElement","createTriggerController","destroyTriggerInteraction","removeClickListener","addClickListener","trigger","triggerEl","getElementById","printIonWarning","configureTriggerInteraction","targetEl","openOverlay","newTopMostOverlay","i","presentedOverlay","nextPresentedOverlay","currentOverlay"],"sources":["node_modules/@ionic/core/dist/collection/utils/focus-trap.js","node_modules/@ionic/core/dist/collection/utils/overlays.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { focusVisibleElement } from \"./helpers\";\n/**\n * This query string selects elements that\n * are eligible to receive focus. We select\n * interactive elements that meet the following\n * criteria:\n * 1. Element does not have a negative tabindex\n * 2. Element does not have `hidden`\n * 3. Element does not have `disabled` for non-Ionic components.\n * 4. Element does not have `disabled` or `disabled=\"true\"` for Ionic components.\n * Note: We need this distinction because `disabled=\"false\"` is\n * valid usage for the disabled property on ion-button.\n */\nexport const focusableQueryString = '[tabindex]:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), input:not([type=hidden]):not([tabindex^=\"-\"]):not([hidden]):not([disabled]), textarea:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), button:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), select:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable[disabled=\"false\"]:not([tabindex^=\"-\"]):not([hidden])';\n/**\n * Focuses the first descendant in a context\n * that can receive focus. If none exists,\n * a fallback element will be focused.\n * This fallback is typically an ancestor\n * container such as a menu or overlay so focus does not\n * leave the container we are trying to trap focus in.\n *\n * If no fallback is specified then we focus the container itself.\n */\nexport const focusFirstDescendant = (ref, fallbackElement) => {\n    const firstInput = ref.querySelector(focusableQueryString);\n    focusElementInContext(firstInput, fallbackElement !== null && fallbackElement !== void 0 ? fallbackElement : ref);\n};\n/**\n * Focuses the last descendant in a context\n * that can receive focus. If none exists,\n * a fallback element will be focused.\n * This fallback is typically an ancestor\n * container such as a menu or overlay so focus does not\n * leave the container we are trying to trap focus in.\n *\n * If no fallback is specified then we focus the container itself.\n */\nexport const focusLastDescendant = (ref, fallbackElement) => {\n    const inputs = Array.from(ref.querySelectorAll(focusableQueryString));\n    const lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;\n    focusElementInContext(lastInput, fallbackElement !== null && fallbackElement !== void 0 ? fallbackElement : ref);\n};\n/**\n * Focuses a particular element in a context. If the element\n * doesn't have anything focusable associated with it then\n * a fallback element will be focused.\n *\n * This fallback is typically an ancestor\n * container such as a menu or overlay so focus does not\n * leave the container we are trying to trap focus in.\n * This should be used instead of the focus() method\n * on most elements because the focusable element\n * may not be the host element.\n *\n * For example, if an ion-button should be focused\n * then we should actually focus the native <button>\n * element inside of ion-button's shadow root, not\n * the host element itself.\n */\nconst focusElementInContext = (hostToFocus, fallbackElement) => {\n    let elementToFocus = hostToFocus;\n    const shadowRoot = hostToFocus === null || hostToFocus === void 0 ? void 0 : hostToFocus.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        elementToFocus = shadowRoot.querySelector(focusableQueryString) || hostToFocus;\n    }\n    if (elementToFocus) {\n        focusVisibleElement(elementToFocus);\n    }\n    else {\n        // Focus fallback element instead of letting focus escape\n        fallbackElement.focus();\n    }\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { doc } from \"./browser/index\";\nimport { focusFirstDescendant, focusLastDescendant, focusableQueryString } from \"./focus-trap\";\nimport { shouldUseCloseWatcher } from \"./hardware-back-button\";\nimport { config } from \"../global/config\";\nimport { getIonMode } from \"../global/ionic-global\";\nimport { CoreDelegate } from \"./framework-delegate\";\nimport { BACKDROP_NO_SCROLL } from \"./gesture/gesture-controller\";\nimport { OVERLAY_BACK_BUTTON_PRIORITY } from \"./hardware-back-button\";\nimport { addEventListener, componentOnReady, focusVisibleElement, getElementRoot, removeEventListener, } from \"./helpers\";\nimport { printIonWarning } from \"./logging\";\nlet lastOverlayIndex = 0;\nlet lastId = 0;\nexport const activeAnimations = new WeakMap();\nconst createController = (tagName) => {\n    return {\n        create(options) {\n            return createOverlay(tagName, options);\n        },\n        dismiss(data, role, id) {\n            return dismissOverlay(document, data, role, tagName, id);\n        },\n        async getTop() {\n            return getPresentedOverlay(document, tagName);\n        },\n    };\n};\nexport const alertController = /*@__PURE__*/ createController('ion-alert');\nexport const actionSheetController = /*@__PURE__*/ createController('ion-action-sheet');\nexport const loadingController = /*@__PURE__*/ createController('ion-loading');\nexport const modalController = /*@__PURE__*/ createController('ion-modal');\n/**\n * @deprecated Use the inline ion-picker component instead.\n */\nexport const pickerController = /*@__PURE__*/ createController('ion-picker-legacy');\nexport const popoverController = /*@__PURE__*/ createController('ion-popover');\nexport const toastController = /*@__PURE__*/ createController('ion-toast');\n/**\n * Prepares the overlay element to be presented.\n */\nexport const prepareOverlay = (el) => {\n    if (typeof document !== 'undefined') {\n        /**\n         * Adds a single instance of event listeners for application behaviors:\n         *\n         * - Escape Key behavior to dismiss an overlay\n         * - Trapping focus within an overlay\n         * - Back button behavior to dismiss an overlay\n         *\n         * This only occurs when the first overlay is created.\n         */\n        connectListeners(document);\n    }\n    const overlayIndex = lastOverlayIndex++;\n    /**\n     * overlayIndex is used in the overlay components to set a zIndex.\n     * This ensures that the most recently presented overlay will be\n     * on top.\n     */\n    el.overlayIndex = overlayIndex;\n};\n/**\n * Assigns an incrementing id to an overlay element, that does not\n * already have an id assigned to it.\n *\n * Used to track unique instances of an overlay element.\n */\nexport const setOverlayId = (el) => {\n    if (!el.hasAttribute('id')) {\n        el.id = `ion-overlay-${++lastId}`;\n    }\n    return el.id;\n};\nexport const createOverlay = (tagName, opts) => {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof window !== 'undefined' && typeof window.customElements !== 'undefined') {\n        return window.customElements.whenDefined(tagName).then(() => {\n            const element = document.createElement(tagName);\n            element.classList.add('overlay-hidden');\n            /**\n             * Convert the passed in overlay options into props\n             * that get passed down into the new overlay.\n             */\n            Object.assign(element, Object.assign(Object.assign({}, opts), { hasController: true }));\n            // append the overlay element to the document body\n            getAppRoot(document).appendChild(element);\n            return new Promise((resolve) => componentOnReady(element, resolve));\n        });\n    }\n    return Promise.resolve();\n};\nconst isOverlayHidden = (overlay) => overlay.classList.contains('overlay-hidden');\n/**\n * Focuses a particular element in an overlay. If the element\n * doesn't have anything focusable associated with it then\n * the overlay itself will be focused.\n * This should be used instead of the focus() method\n * on most elements because the focusable element\n * may not be the host element.\n *\n * For example, if an ion-button should be focused\n * then we should actually focus the native <button>\n * element inside of ion-button's shadow root, not\n * the host element itself.\n */\nconst focusElementInOverlay = (hostToFocus, overlay) => {\n    let elementToFocus = hostToFocus;\n    const shadowRoot = hostToFocus === null || hostToFocus === void 0 ? void 0 : hostToFocus.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        elementToFocus = shadowRoot.querySelector(focusableQueryString) || hostToFocus;\n    }\n    if (elementToFocus) {\n        focusVisibleElement(elementToFocus);\n    }\n    else {\n        // Focus overlay instead of letting focus escape\n        overlay.focus();\n    }\n};\n/**\n * Traps keyboard focus inside of overlay components.\n * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html\n * This includes the following components: Action Sheet, Alert, Loading, Modal,\n * Picker, and Popover.\n * Should NOT include: Toast\n */\nconst trapKeyboardFocus = (ev, doc) => {\n    const lastOverlay = getPresentedOverlay(doc, 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker-legacy,ion-popover');\n    const target = ev.target;\n    /**\n     * If no active overlay, ignore this event.\n     *\n     * If this component uses the shadow dom,\n     * this global listener is pointless\n     * since it will not catch the focus\n     * traps as they are inside the shadow root.\n     * We need to add a listener to the shadow root\n     * itself to ensure the focus trap works.\n     */\n    if (!lastOverlay || !target) {\n        return;\n    }\n    /**\n     * If the ion-disable-focus-trap class\n     * is present on an overlay, then this component\n     * instance has opted out of focus trapping.\n     * An example of this is when the sheet modal\n     * has a backdrop that is disabled. The content\n     * behind the sheet should be focusable until\n     * the backdrop is enabled.\n     */\n    if (lastOverlay.classList.contains(FOCUS_TRAP_DISABLE_CLASS)) {\n        return;\n    }\n    const trapScopedFocus = () => {\n        /**\n         * If we are focusing the overlay, clear\n         * the last focused element so that hitting\n         * tab activates the first focusable element\n         * in the overlay wrapper.\n         */\n        if (lastOverlay === target) {\n            lastOverlay.lastFocus = undefined;\n            /**\n             * Toasts can be presented from an overlay.\n             * However, focus should still be returned to\n             * the overlay when clicking a toast. Normally,\n             * focus would be returned to the last focusable\n             * descendant in the overlay which may not always be\n             * the button that the toast was presented from. In this case,\n             * the focus may be returned to an unexpected element.\n             * To account for this, we make sure to return focus to the\n             * last focused element in the overlay if focus is\n             * moved to the toast.\n             */\n        }\n        else if (target.tagName === 'ION-TOAST') {\n            focusElementInOverlay(lastOverlay.lastFocus, lastOverlay);\n            /**\n             * Otherwise, we must be focusing an element\n             * inside of the overlay. The two possible options\n             * here are an input/button/etc or the ion-focus-trap\n             * element. The focus trap element is used to prevent\n             * the keyboard focus from leaving the overlay when\n             * using Tab or screen assistants.\n             */\n        }\n        else {\n            /**\n             * We do not want to focus the traps, so get the overlay\n             * wrapper element as the traps live outside of the wrapper.\n             */\n            const overlayRoot = getElementRoot(lastOverlay);\n            if (!overlayRoot.contains(target)) {\n                return;\n            }\n            const overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');\n            if (!overlayWrapper) {\n                return;\n            }\n            /**\n             * If the target is inside the wrapper, let the browser\n             * focus as normal and keep a log of the last focused element.\n             * Additionally, if the backdrop was tapped we should not\n             * move focus back inside the wrapper as that could cause\n             * an interactive elements focus state to activate.\n             */\n            if (overlayWrapper.contains(target) || target === overlayRoot.querySelector('ion-backdrop')) {\n                lastOverlay.lastFocus = target;\n            }\n            else {\n                /**\n                 * Otherwise, we must have focused one of the focus traps.\n                 * We need to wrap the focus to either the first element\n                 * or the last element.\n                 */\n                /**\n                 * Once we call `focusFirstDescendant` and focus the first\n                 * descendant, another focus event will fire which will\n                 * cause `lastOverlay.lastFocus` to be updated before\n                 * we can run the code after that. We will cache the value\n                 * here to avoid that.\n                 */\n                const lastFocus = lastOverlay.lastFocus;\n                // Focus the first element in the overlay wrapper\n                focusFirstDescendant(overlayWrapper, lastOverlay);\n                /**\n                 * If the cached last focused element is the\n                 * same as the active element, then we need\n                 * to wrap focus to the last descendant. This happens\n                 * when the first descendant is focused, and the user\n                 * presses Shift + Tab. The previous line will focus\n                 * the same descendant again (the first one), causing\n                 * last focus to equal the active element.\n                 */\n                if (lastFocus === doc.activeElement) {\n                    focusLastDescendant(overlayWrapper, lastOverlay);\n                }\n                lastOverlay.lastFocus = doc.activeElement;\n            }\n        }\n    };\n    const trapShadowFocus = () => {\n        /**\n         * If the target is inside the wrapper, let the browser\n         * focus as normal and keep a log of the last focused element.\n         */\n        if (lastOverlay.contains(target)) {\n            lastOverlay.lastFocus = target;\n            /**\n             * Toasts can be presented from an overlay.\n             * However, focus should still be returned to\n             * the overlay when clicking a toast. Normally,\n             * focus would be returned to the last focusable\n             * descendant in the overlay which may not always be\n             * the button that the toast was presented from. In this case,\n             * the focus may be returned to an unexpected element.\n             * To account for this, we make sure to return focus to the\n             * last focused element in the overlay if focus is\n             * moved to the toast.\n             */\n        }\n        else if (target.tagName === 'ION-TOAST') {\n            focusElementInOverlay(lastOverlay.lastFocus, lastOverlay);\n        }\n        else {\n            /**\n             * Otherwise, we are about to have focus\n             * go out of the overlay. We need to wrap\n             * the focus to either the first element\n             * or the last element.\n             */\n            /**\n             * Once we call `focusFirstDescendant` and focus the first\n             * descendant, another focus event will fire which will\n             * cause `lastOverlay.lastFocus` to be updated before\n             * we can run the code after that. We will cache the value\n             * here to avoid that.\n             */\n            const lastFocus = lastOverlay.lastFocus;\n            // Focus the first element in the overlay wrapper\n            focusFirstDescendant(lastOverlay);\n            /**\n             * If the cached last focused element is the\n             * same as the active element, then we need\n             * to wrap focus to the last descendant. This happens\n             * when the first descendant is focused, and the user\n             * presses Shift + Tab. The previous line will focus\n             * the same descendant again (the first one), causing\n             * last focus to equal the active element.\n             */\n            if (lastFocus === doc.activeElement) {\n                focusLastDescendant(lastOverlay);\n            }\n            lastOverlay.lastFocus = doc.activeElement;\n        }\n    };\n    if (lastOverlay.shadowRoot) {\n        trapShadowFocus();\n    }\n    else {\n        trapScopedFocus();\n    }\n};\nconst connectListeners = (doc) => {\n    if (lastOverlayIndex === 0) {\n        lastOverlayIndex = 1;\n        doc.addEventListener('focus', (ev) => {\n            trapKeyboardFocus(ev, doc);\n        }, true);\n        // handle back-button click\n        doc.addEventListener('ionBackButton', (ev) => {\n            const lastOverlay = getPresentedOverlay(doc);\n            if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n                ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {\n                    /**\n                     * Do not return this promise otherwise\n                     * the hardware back button utility will\n                     * be blocked until the overlay dismisses.\n                     * This is important for a modal with canDismiss.\n                     * If the application presents a confirmation alert\n                     * in the \"canDismiss\" callback, then it will be impossible\n                     * to use the hardware back button to dismiss the alert\n                     * dialog because the hardware back button utility\n                     * is blocked on waiting for the modal to dismiss.\n                     */\n                    lastOverlay.dismiss(undefined, BACKDROP);\n                });\n            }\n        });\n        /**\n         * Handle ESC to close overlay.\n         * CloseWatcher also handles pressing the Esc\n         * key, so if a browser supports CloseWatcher then\n         * this behavior will be handled via the ionBackButton\n         * event.\n         */\n        if (!shouldUseCloseWatcher()) {\n            doc.addEventListener('keydown', (ev) => {\n                if (ev.key === 'Escape') {\n                    const lastOverlay = getPresentedOverlay(doc);\n                    if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n                        lastOverlay.dismiss(undefined, BACKDROP);\n                    }\n                }\n            });\n        }\n    }\n};\nexport const dismissOverlay = (doc, data, role, overlayTag, id) => {\n    const overlay = getPresentedOverlay(doc, overlayTag, id);\n    if (!overlay) {\n        return Promise.reject('overlay does not exist');\n    }\n    return overlay.dismiss(data, role);\n};\n/**\n * Returns a list of all overlays in the DOM even if they are not presented.\n */\nexport const getOverlays = (doc, selector) => {\n    if (selector === undefined) {\n        selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker-legacy,ion-popover,ion-toast';\n    }\n    return Array.from(doc.querySelectorAll(selector)).filter((c) => c.overlayIndex > 0);\n};\n/**\n * Returns a list of all presented overlays.\n * Inline overlays can exist in the DOM but not be presented,\n * so there are times when we want to exclude those.\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n */\nconst getPresentedOverlays = (doc, overlayTag) => {\n    return getOverlays(doc, overlayTag).filter((o) => !isOverlayHidden(o));\n};\n/**\n * Returns a presented overlay element.\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n * @param id The unique identifier for the overlay instance.\n * @returns The overlay element or `undefined` if no overlay element is found.\n */\nexport const getPresentedOverlay = (doc, overlayTag, id) => {\n    const overlays = getPresentedOverlays(doc, overlayTag);\n    return id === undefined ? overlays[overlays.length - 1] : overlays.find((o) => o.id === id);\n};\n/**\n * When an overlay is presented, the main\n * focus is the overlay not the page content.\n * We need to remove the page content from the\n * accessibility tree otherwise when\n * users use \"read screen from top\" gestures with\n * TalkBack and VoiceOver, the screen reader will begin\n * to read the content underneath the overlay.\n *\n * We need a container where all page components\n * exist that is separate from where the overlays\n * are added in the DOM. For most apps, this element\n * is the top most ion-router-outlet. In the event\n * that devs are not using a router,\n * they will need to add the \"ion-view-container-root\"\n * id to the element that contains all of their views.\n *\n * TODO: If Framework supports having multiple top\n * level router outlets we would need to update this.\n * Example: One outlet for side menu and one outlet\n * for main content.\n */\nexport const setRootAriaHidden = (hidden = false) => {\n    const root = getAppRoot(document);\n    const viewContainer = root.querySelector('ion-router-outlet, ion-nav, #ion-view-container-root');\n    if (!viewContainer) {\n        return;\n    }\n    if (hidden) {\n        viewContainer.setAttribute('aria-hidden', 'true');\n    }\n    else {\n        viewContainer.removeAttribute('aria-hidden');\n    }\n};\nexport const present = async (overlay, name, iosEnterAnimation, mdEnterAnimation, opts) => {\n    var _a, _b;\n    if (overlay.presented) {\n        return;\n    }\n    setRootAriaHidden(true);\n    document.body.classList.add(BACKDROP_NO_SCROLL);\n    hideOverlaysFromScreenReaders(overlay.el);\n    overlay.presented = true;\n    overlay.willPresent.emit();\n    (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();\n    const mode = getIonMode(overlay);\n    // get the user's animation fn if one was provided\n    const animationBuilder = overlay.enterAnimation\n        ? overlay.enterAnimation\n        : config.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);\n    const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n    if (completed) {\n        overlay.didPresent.emit();\n        (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();\n    }\n    /**\n     * When an overlay that steals focus\n     * is dismissed, focus should be returned\n     * to the element that was focused\n     * prior to the overlay opening. Toast\n     * does not steal focus and is excluded\n     * from returning focus as a result.\n     */\n    if (overlay.el.tagName !== 'ION-TOAST') {\n        restoreElementFocus(overlay.el);\n    }\n    /**\n     * If the focused element is already\n     * inside the overlay component then\n     * focus should not be moved from that\n     * to the overlay container.\n     */\n    if (overlay.keyboardClose && (document.activeElement === null || !overlay.el.contains(document.activeElement))) {\n        overlay.el.focus();\n    }\n    /**\n     * If this overlay was previously dismissed without being\n     * the topmost one (such as by manually calling dismiss()),\n     * it would still have aria-hidden on being presented again.\n     * Removing it here ensures the overlay is visible to screen\n     * readers.\n     */\n    overlay.el.removeAttribute('aria-hidden');\n};\n/**\n * When an overlay component is dismissed,\n * focus should be returned to the element\n * that presented the overlay. Otherwise\n * focus will be set on the body which\n * means that people using screen readers\n * or tabbing will need to re-navigate\n * to where they were before they\n * opened the overlay.\n */\nconst restoreElementFocus = async (overlayEl) => {\n    let previousElement = document.activeElement;\n    if (!previousElement) {\n        return;\n    }\n    const shadowRoot = previousElement === null || previousElement === void 0 ? void 0 : previousElement.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        previousElement = shadowRoot.querySelector(focusableQueryString) || previousElement;\n    }\n    await overlayEl.onDidDismiss();\n    /**\n     * After onDidDismiss, the overlay loses focus\n     * because it is removed from the document\n     *\n     * > An element will also lose focus [...]\n     * > if the element is removed from the document)\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event\n     *\n     * Additionally, `document.activeElement` returns:\n     *\n     * > The Element which currently has focus,\n     * > `<body>` or null if there is\n     * > no focused element.\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement#value\n     *\n     * However, if the user has already focused\n     * an element sometime between onWillDismiss\n     * and onDidDismiss (for example, focusing a\n     * text box after tapping a button in an\n     * action sheet) then don't restore focus to\n     * previous element\n     */\n    if (document.activeElement === null || document.activeElement === document.body) {\n        previousElement.focus();\n    }\n};\nexport const dismiss = async (overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) => {\n    var _a, _b;\n    if (!overlay.presented) {\n        return false;\n    }\n    const lastOverlay = doc !== undefined && getPresentedOverlays(doc).length === 1;\n    /**\n     * If this is the last visible overlay then\n     * we want to re-add the root to the accessibility tree.\n     */\n    if (lastOverlay) {\n        setRootAriaHidden(false);\n        document.body.classList.remove(BACKDROP_NO_SCROLL);\n    }\n    overlay.presented = false;\n    try {\n        // Overlay contents should not be clickable during dismiss\n        overlay.el.style.setProperty('pointer-events', 'none');\n        overlay.willDismiss.emit({ data, role });\n        (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({ data, role });\n        const mode = getIonMode(overlay);\n        const animationBuilder = overlay.leaveAnimation\n            ? overlay.leaveAnimation\n            : config.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation);\n        // If dismissed via gesture, no need to play leaving animation again\n        if (role !== GESTURE) {\n            await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n        }\n        overlay.didDismiss.emit({ data, role });\n        (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({ data, role });\n        // Get a reference to all animations currently assigned to this overlay\n        // Then tear them down to return the overlay to its initial visual state\n        const animations = activeAnimations.get(overlay) || [];\n        animations.forEach((ani) => ani.destroy());\n        activeAnimations.delete(overlay);\n        /**\n         * Make overlay hidden again in case it is being reused.\n         * We can safely remove pointer-events: none as\n         * overlay-hidden will set display: none.\n         */\n        overlay.el.classList.add('overlay-hidden');\n        overlay.el.style.removeProperty('pointer-events');\n        /**\n         * Clear any focus trapping references\n         * when the overlay is dismissed.\n         */\n        if (overlay.el.lastFocus !== undefined) {\n            overlay.el.lastFocus = undefined;\n        }\n    }\n    catch (err) {\n        console.error(err);\n    }\n    overlay.el.remove();\n    revealOverlaysToScreenReaders();\n    return true;\n};\nconst getAppRoot = (doc) => {\n    return doc.querySelector('ion-app') || doc.body;\n};\nconst overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {\n    // Make overlay visible in case it's hidden\n    baseEl.classList.remove('overlay-hidden');\n    const aniRoot = overlay.el;\n    const animation = animationBuilder(aniRoot, opts);\n    if (!overlay.animated || !config.getBoolean('animated', true)) {\n        animation.duration(0);\n    }\n    if (overlay.keyboardClose) {\n        animation.beforeAddWrite(() => {\n            const activeElement = baseEl.ownerDocument.activeElement;\n            if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.matches('input,ion-input, ion-textarea')) {\n                activeElement.blur();\n            }\n        });\n    }\n    const activeAni = activeAnimations.get(overlay) || [];\n    activeAnimations.set(overlay, [...activeAni, animation]);\n    await animation.play();\n    return true;\n};\nexport const eventMethod = (element, eventName) => {\n    let resolve;\n    const promise = new Promise((r) => (resolve = r));\n    onceEvent(element, eventName, (event) => {\n        resolve(event.detail);\n    });\n    return promise;\n};\nexport const onceEvent = (element, eventName, callback) => {\n    const handler = (ev) => {\n        removeEventListener(element, eventName, handler);\n        callback(ev);\n    };\n    addEventListener(element, eventName, handler);\n};\nexport const isCancel = (role) => {\n    return role === 'cancel' || role === BACKDROP;\n};\nconst defaultGate = (h) => h();\n/**\n * Calls a developer provided method while avoiding\n * Angular Zones. Since the handler is provided by\n * the developer, we should throw any errors\n * received so that developer-provided bug\n * tracking software can log it.\n */\nexport const safeCall = (handler, arg) => {\n    if (typeof handler === 'function') {\n        const jmp = config.get('_zoneGate', defaultGate);\n        return jmp(() => {\n            try {\n                return handler(arg);\n            }\n            catch (e) {\n                throw e;\n            }\n        });\n    }\n    return undefined;\n};\nexport const BACKDROP = 'backdrop';\nexport const GESTURE = 'gesture';\nexport const OVERLAY_GESTURE_PRIORITY = 39;\n/**\n * Creates a delegate controller.\n *\n * Requires that the component has the following properties:\n * - `el: HTMLElement`\n * - `hasController: boolean`\n * - `delegate?: FrameworkDelegate`\n *\n * @param ref The component class instance.\n */\nexport const createDelegateController = (ref) => {\n    let inline = false;\n    let workingDelegate;\n    const coreDelegate = CoreDelegate();\n    /**\n     * Determines whether or not an overlay is being used\n     * inline or via a controller/JS and returns the correct delegate.\n     * By default, subsequent calls to getDelegate will use\n     * a cached version of the delegate.\n     * This is useful for calling dismiss after present,\n     * so that the correct delegate is given.\n     * @param force `true` to force the non-cached version of the delegate.\n     * @returns The delegate to use and whether or not the overlay is inline.\n     */\n    const getDelegate = (force = false) => {\n        if (workingDelegate && !force) {\n            return {\n                delegate: workingDelegate,\n                inline,\n            };\n        }\n        const { el, hasController, delegate } = ref;\n        /**\n         * If using overlay inline\n         * we potentially need to use the coreDelegate\n         * so that this works in vanilla JS apps.\n         * If a developer has presented this component\n         * via a controller, then we can assume\n         * the component is already in the\n         * correct place.\n         */\n        const parentEl = el.parentNode;\n        inline = parentEl !== null && !hasController;\n        workingDelegate = inline ? delegate || coreDelegate : delegate;\n        return { inline, delegate: workingDelegate };\n    };\n    /**\n     * Attaches a component in the DOM. Teleports the component\n     * to the root of the app.\n     * @param component The component to optionally construct and append to the element.\n     */\n    const attachViewToDom = async (component) => {\n        const { delegate } = getDelegate(true);\n        if (delegate) {\n            return await delegate.attachViewToDom(ref.el, component);\n        }\n        const { hasController } = ref;\n        if (hasController && component !== undefined) {\n            throw new Error('framework delegate is missing');\n        }\n        return null;\n    };\n    /**\n     * Moves a component back to its original location in the DOM.\n     */\n    const removeViewFromDom = () => {\n        const { delegate } = getDelegate();\n        if (delegate && ref.el !== undefined) {\n            delegate.removeViewFromDom(ref.el.parentElement, ref.el);\n        }\n    };\n    return {\n        attachViewToDom,\n        removeViewFromDom,\n    };\n};\n/**\n * Constructs a trigger interaction for an overlay.\n * Presents an overlay when the trigger is clicked.\n *\n * Usage:\n * ```ts\n * triggerController = createTriggerController();\n * triggerController.addClickListener(el, trigger);\n * ```\n */\nexport const createTriggerController = () => {\n    let destroyTriggerInteraction;\n    /**\n     * Removes the click listener from the trigger element.\n     */\n    const removeClickListener = () => {\n        if (destroyTriggerInteraction) {\n            destroyTriggerInteraction();\n            destroyTriggerInteraction = undefined;\n        }\n    };\n    /**\n     * Adds a click listener to the trigger element.\n     * Presents the overlay when the trigger is clicked.\n     * @param el The overlay element.\n     * @param trigger The ID of the element to add a click listener to.\n     */\n    const addClickListener = (el, trigger) => {\n        removeClickListener();\n        const triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;\n        if (!triggerEl) {\n            printIonWarning(`A trigger element with the ID \"${trigger}\" was not found in the DOM. The trigger element must be in the DOM when the \"trigger\" property is set on an overlay component.`, el);\n            return;\n        }\n        const configureTriggerInteraction = (targetEl, overlayEl) => {\n            const openOverlay = () => {\n                overlayEl.present();\n            };\n            targetEl.addEventListener('click', openOverlay);\n            return () => {\n                targetEl.removeEventListener('click', openOverlay);\n            };\n        };\n        destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el);\n    };\n    return {\n        addClickListener,\n        removeClickListener,\n    };\n};\n/**\n * Ensure that underlying overlays have aria-hidden if necessary so that screen readers\n * cannot move focus to these elements. Note that we cannot rely on focus/focusin/focusout\n * events here because those events do not fire when the screen readers moves to a non-focusable\n * element such as text.\n * Without this logic screen readers would be able to move focus outside of the top focus-trapped overlay.\n *\n * @param newTopMostOverlay - The overlay that is being presented. Since the overlay has not been\n * fully presented yet at the time this function is called it will not be included in the getPresentedOverlays result.\n */\nconst hideOverlaysFromScreenReaders = (newTopMostOverlay) => {\n    var _a;\n    if (doc === undefined)\n        return;\n    const overlays = getPresentedOverlays(doc);\n    for (let i = overlays.length - 1; i >= 0; i--) {\n        const presentedOverlay = overlays[i];\n        const nextPresentedOverlay = (_a = overlays[i + 1]) !== null && _a !== void 0 ? _a : newTopMostOverlay;\n        /**\n         * If next overlay has aria-hidden then all remaining overlays will have it too.\n         * Or, if the next overlay is a Toast that does not have aria-hidden then current overlay\n         * should not have aria-hidden either so focus can remain in the current overlay.\n         */\n        if (nextPresentedOverlay.hasAttribute('aria-hidden') || nextPresentedOverlay.tagName !== 'ION-TOAST') {\n            presentedOverlay.setAttribute('aria-hidden', 'true');\n        }\n    }\n};\n/**\n * When dismissing an overlay we need to reveal the new top-most overlay to screen readers.\n * If the top-most overlay is a Toast we potentially need to reveal more overlays since\n * focus is never automatically moved to the Toast.\n */\nconst revealOverlaysToScreenReaders = () => {\n    if (doc === undefined)\n        return;\n    const overlays = getPresentedOverlays(doc);\n    for (let i = overlays.length - 1; i >= 0; i--) {\n        const currentOverlay = overlays[i];\n        /**\n         * If the current we are looking at is a Toast then we can remove aria-hidden.\n         * However, we potentially need to keep looking at the overlay stack because there\n         * could be more Toasts underneath. Additionally, we need to unhide the closest non-Toast\n         * overlay too so focus can move there since focus is never automatically moved to the Toast.\n         */\n        currentOverlay.removeAttribute('aria-hidden');\n        /**\n         * If we found a non-Toast element then we can just remove aria-hidden and stop searching entirely\n         * since this overlay should always receive focus. As a result, all underlying overlays should still\n         * be hidden from screen readers.\n         */\n        if (currentOverlay.tagName !== 'ION-TOAST') {\n            break;\n        }\n    }\n};\nexport const FOCUS_TRAP_DISABLE_CLASS = 'ion-disable-focus-trap';\n"],"mappings":"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"}